module gamble_5_105 is

!int_bits 32
--!nat_bits 32

channel play is
	(p: real)
end channel

channel gameend is
	(p:nat)
end channel

type cofval is
	array[1..6] of real
end type

function factorial(t:nat) :nat is
	var r,i:nat in
		r := 1;
		i := 1;
		while (i < t) loop
			i := i+1;
			r := r*i
		end loop;
		return r
	end var
end function

function binomial(x,y:nat) : real is
	var res,nfact,kfact,nmkfact:nat,ret:real in
		nfact := factorial(x);
		kfact := factorial(y);
		nmkfact := factorial(x-y);
		res := kfact*nmkfact;
		ret := real(nfact)/real(res);
		return ret
	end var
end function

function pow(x:real,n:nat) :real is
	var pow:real,i:nat in
		i := 1;
		pow := x;
		while (i < n) loop
			i := i+1;
			pow := pow*x
		end loop;
		return pow
	end var
end function


process MAIN[gamble,sit,not_sit:play,home,drunk:gameend] is
	var a,b: cofval,i,no_of_games: nat,start,target,gain_amt,loss_amt,sit_penalty:int, win_prob,sit_prob: real in
	
		no_of_games := 5;		--If you change this, also change the size of the array, it will be one more than the no of games
		start := 10 of int;
		target := 100000 of int;
		gain_amt := 8;
		loss_amt := 6;
		sit_penalty := 2;
		
		win_prob := 0.7;
		sit_prob := 0.001;
		
		i := 1;
		
		a := cofval(1.0 of real);
		b := cofval(1.0 of real);
		
		--this while loop is calculating the possible probabilities and their cofficients
		while (i < no_of_games+2) loop
			a[i] := binomial(no_of_games,i-1);
			
			if (i=1) then
				b[1] := pow(win_prob,no_of_games)
			else
				b[i] := (b[i-1]/win_prob)*(1.0-win_prob)
			end if;
			
			i := i+1
		end loop;
		
		--One has to play the first game, after which he/she will have the option to sit OR to play
		choice_to_sit[gamble,sit,not_sit,home,drunk](no_of_games,start,target,gain_amt,loss_amt,sit_penalty,sit_prob,a,b)

	end var
end process



process choice_to_sit[gamble,sit,not_sit:play,home,drunk:gameend](no_of_games:nat,start,target,gain_amt,loss_amt,sit_penalty:int,sit_prob:real, a,b:cofval) is
		if (start < loss_amt) then
			loop drunk(1 of nat) end loop

		elsif (loss_amt <= start and start < target) then
			alt
				sit(sit_prob);
				choice_to_sit[gamble,sit,not_sit,home,drunk](no_of_games,start-2,target,gain_amt,loss_amt,sit_penalty,sit_prob, a,b)
			[]
				not_sit(1.0-sit_prob);
				plays[gamble,sit,not_sit,home,drunk](no_of_games,start,target,gain_amt,loss_amt,sit_penalty,sit_prob, a,b)
			end alt
		
		
		elsif(target <= start) then
			loop home(1 of nat) end loop
		end if
end process


process plays[gamble,sit,not_sit:play,home,drunk:gameend](no_of_games:nat,start,target,gain_amt,loss_amt,sit_penalty:int,sit_prob:real, a,b:cofval) is
	var N: nat in
		N := any Nat where 1 <= N and N <= no_of_games+1;
		gamble(a[N]*b[N]);
		choice_to_sit[gamble,sit,not_sit,home,drunk](no_of_games,(start+((int(no_of_games)-(int(N)-1))*gain_amt)-((int(N)-1)*loss_amt)),target,gain_amt,loss_amt,sit_penalty,sit_prob, a,b)
	end var
end process


end module
